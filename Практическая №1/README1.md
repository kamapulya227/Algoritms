# Сравнение создания списков (массивов) и организации стеков в Java, Python и C++ (Хусяинова Камиля, УИБО-10-24)
## Создание списка (массива)
### Python
```py
list=['март','апрель','май']
```
- Используется встроенный тип list как динамический массив
- Динамическая типизация
- Литералы квадратных скобок для создания
- Простой синтаксис добавления элементов

### C++
```cpp
## Работа с двусвязными списками

### C++ (std::list)
```cpp
#include <iostream>
#include <list> 

int main() {
    std::list<int> myList; // Создаем список целых чисел

    // Добавление элементов в конец списка
    myList.push_back(10);
    myList.push_back(20);
    myList.push_back(30);

    // Вставка элемента в начало списка
    myList.push_front(5);

    // Вывод элементов списка
    std::cout << "Содержимое списка: ";
    for (int val : myList) {
        std::cout << val << " ";
    }
    std::cout << std::endl; // Вывод: 5 10 20 30
}
```
- Используется std::list из Standard Template Library (STL)
- Двусвязный список с эффективной вставкой/удалением в любом месте
- Методы push_back() для добавления в конец
- Методы push_front() для добавления в начало
- Range-based for loop для итерации по элементам
- Требуется подключение заголовочного файла <list>

### Java
```java
import java.util.ArrayList;
import java.util.List;

public class ListExample {
    public static void main(String[] args) {
        // Создаем пустой список строк
        List<String> fruits = new ArrayList<>();

        // Добавляем элементы в список
        fruits.add("Яблоко");
        fruits.add("Банан");
        fruits.add("Апельсин");

        // Печатаем список
        System.out.println("Список фруктов: " + fruits);

        // Получаем элемент по индексу
        System.out.println("Первый фрукт: " + fruits.get(0));

        // Удаляем элемент
        fruits.remove("Банан");
        System.out.println("Список после удаления банана: " + fruits);
    }
}
```
- Используется ArrayList из Java Collections Framework
- Интерфейс List<String> для типобезопасности
- Динамический массив с автоматическим расширением
- Метод add() для добавления элементов
- Метод get(index) для доступа по индексу
- Метод remove(element) для удаления по значению
- Автоматическое преобразование в строку при печати
## Организация стека
### Python
```py
stack = []
stack.append(1)
stack.append(2)
```
- Стек реализуется через стандартный список (list)
- Методы append() для добавления и pop() для извлечения
### C++
```cpp
#include <iostream>
#include <stack> 

int main() {
    std::stack<int> myStack; // Создаем стек целых чисел

    // Добавление элементов в стек
    myStack.push(100);
    myStack.push(200);
    myStack.push(300);

    std::cout << "Размер стека: " << myStack.size() << std::endl; // Вывод: 3

    // Удаление и вывод элемента с вершины стека
    std::cout << "Извлекаем элементы из стека:" << std::endl;
    while (!myStack.empty()) {
        std::cout << myStack.top() << " "; // Получаем элемент с вершины
        myStack.pop(); // Удаляем элемент с вершины
    }
    std::cout << std::endl; // Вывод: 300 200 100

    return 0;
}
```
- Используется std::stack из Standard Template Library (STL)
- Требуется подключение заголовочного файла <stack>
- Метод push() для добавления элементов в стек
- Метод pop() для удаления элемента с вершины стека
- Метод top() для получения элемента с вершины без удаления
- Метод size() для получения текущего размера стека
- Метод empty() для проверки пустоты стека
- Принцип LIFO (Last In, First Out) - последний пришел, первый ушел
### Java
```java
import java.util.Stack;

public class StackExample {
    public static void main(String[] args) {
        // Создаем пустой стек целых чисел
        Stack<Integer> numberStack = new Stack<>();

        // Добавляем элементы на вершину стека
        numberStack.push(10);
        numberStack.push(20);
        numberStack.push(30);

        // Печатаем стек
        System.out.println("Стек чисел: " + numberStack);

        // Извлекаем элемент с вершины стека
        int topElement = numberStack.pop();
        System.out.println("Извлечен элемент: " + topElement);
        System.out.println("Стек после извлечения: " + numberStack);

        // Смотрим на верхний элемент, не извлекая его
        System.out.println("Верхний элемент: " + numberStack.peek());
    }
}
```
- Используется класс Stack<Integer> из пакета java.util
- Дженерик тип Integer для типобезопасности
- Метод push() для добавления элементов на вершину стека
- Метод pop() для извлечения и удаления элемента с вершины
- Метод peek() для просмотра верхнего элемента без удаления
- Автоматическое строковое представление при печати
- Принцип LIFO (Last In, First Out)
## Вывод
В каждом языке массивы и стеки работаем по своему. Java предлагает строгую типизацию и богатую стандартную библиотеку коллекций, обеспечивая безопасность и предсказуемость работы с данными. C++ предоставляет максимальный контроль над памятью и высокую производительность через STL, но требует большего внимания к деталям управления ресурсами. Python выделяется минималистичным синтаксисом и простотой использования, предлагая динамические структуры данных "из коробки" ценой некоторой потери производительности.

Каждый язык имеет свои сильные стороны: Java — для кроссплатформенных enterprise-решений, C++ — для высокопроизводительных систем, Python — для быстрой разработки и прототипирования. Выбор зависит от конкретных требований проекта: необходимости в производительности, простоте разработки или типобезопасности.
