# __Задание 3: Работа с массивами__
# Вариант 7
## Задача:
__Напишите рекурсивную функцию для нахождения максимального элемента в массиве.__
## Как работает алгоритм для Python:
  Функция принимает массив ```arr``` и его длину ```n```. Базис рекурсии: если ```n == 1```, возвращаем единственный элемент ```arr[0]```. Рекурсивный вызов: ищем максимум в подмассиве длины ```n‑1``` (без последнего элемента). Сравнение: сравниваем последний элемент ```arr[n‑1]``` с найденным максимумом остатка. Возврат: возвращаем больший из двух.
## Как работает алгоритм для C++:
  Функция принимает константную ссылку на вектор ```arr``` и длину ```n```. Базис: при ```n == 1``` возвращаем ```arr[0]```. Рекурсия: вызываем ```find_max``` для ```n‑1```, сохраняем результат в ```max_of_rest```. Сравнение: используем тернарный оператор для выбора максимума между ```arr[n‑1]``` и ```max_of_rest```. Возврат выбранного значения.
## Как работает алгоритм для Java:
   Функция принимает массив ```arr``` и длину ```n```. Базис: если ```n == 1```, возвращаем ```arr[0]```. Рекурсия: вызываем ```findMax для n‑1```, сохраняем результат в ```maxOfRest```. Сравнение: через тернарный оператор выбираем максимум между ```arr[n‑1]``` и ```maxOfRest```. Возврат результата.
## На выходе в каждом коде получается: 
Максимальный элемент: 9
## Временная сложность:
_O(n)_
## Почему эта временная сложность?
Сложность _O(n)_ обусловлена тем, что:

    1. алгоритм делает n рекурсивных шагов,

    2. на каждом шаге выполняется константное количество операций,

    3. все n элементов обрабатываются ровно по одному разу.

Это оптимальная сложность для задачи поиска максимума, так как любой алгоритм обязан хотя бы один раз «посмотреть» на каждый элемент массива.
## Контрольный вопрос №5 :

### __Стратегия «разделяй и властвуй__ решает задачу в три этапа:

1.  **Разделяй:** Разбей большую задачу на меньшие подзадачи.
2.  **Властвуй:** Рекурсивно реши эти подзадачи. Если подзадача стала элементарной, реши её напрямую.
3.  **Объединяй:** Скомбинируй решения подзадач в решение исходной задачи.

### __Алгоритм сортировки слиянием__ — это прямой пример этой стратегии.

*   Разделяй: Исходный массив рекурсивно разделяется пополам, пока не останутся подмассивы из одного элемента. Массив из одного элемента условно считается отсортированным (это базовый случай рекурсии).
*   Властвуй: На этом этапе мы имеем множество отсортированных подмассивов размером в один элемент.
*   Объединяй: Начинается процесс слияния. Пары отсортированных массивов объединяются в новые отсортированные массивы. Этот процесс повторяется до тех пор, пока не будет собран один полностью отсортированный массив. Слияние происходит путём попарного сравнения элементов из двух массивов и выбора наименьшего.
