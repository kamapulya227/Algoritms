# Контрольная работа по алгоритмическим структурам сортировки и поиска на языках: C++, Python, Java. (Хусяинова Камиля, УИБО-10-24)
# *Алгоритмы сортировки*
## 1. Анализ алгоритма сортировки выбором
### Определение:
Сортировка выбором (Selection Sort) — на каждом шаге алгоритма находят минимальный элемент среди последних и меняют его местами с текущим элементом в массиве.
### __Как работает:__
1. Внешний цикл (for) последовательно перебирает элементы массива слева направо.
2. Для каждого шага внешнего цикла выполняется внутренняя проверка оставшихся элементов для поиска минимального.
3. Найденный минимальный элемент заменяется с текущим элементом внешней проверки.
### __Код выводит:__  
Отсортированный массив: [11, 12, 22, 25, 64]
### __Оценка временной сложности:__
О(n²), где n — длина массива.

## 2. Анализ алгоритма cортировки обменом (пузырьком)
### Определение:
Сортировка обменом (пузырьком) (Bubble Sort) — алгоритм проходит по списку несколько раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Процесс повторяется до тех пор, пока список полностью не отсортируется.
### __Как работает:__
1. Во внешнем цикле пробегаемся по всему массиву столько раз, сколько элементов.
2. Во внутреннем цикле выполняем сравнительные операции и меняем элементы местами, если порядок неверный.
3. Операция останавливается досрочно, если ни одна пара не была поменяна местами.
### __Код выводит:__  
Исходный массив: [64, 34, 25, 12, 22, 11, 90]
Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]
### __Оценка временной сложности:__
О(n²), оптимизация даёт лучшую производительность в почти отсортированном массиве (O(n)).

## 3. Анализ алгоритма сортировка вставками 
### Определение:
(Insertion Sort) — алгоритм строит отсортированную часть списка, постепенно вставляя каждый элемент на своё место. Он начинает с первого элемента и перемещается вправо, сравнивая каждый элемент с предыдущими элементами и вставляя его на правильное место.
### __Как работает:__
1. Сначала мы проходим по массиву, начиная со второго элемента (arr[1]), считая первые два элемента частью уже отсортированного участка.
2. Для каждого нового элемента (key) ищем подходящую позицию в левой части массива путём сдвига больших элементов вправо.
3. Когда подходящее место найдено, вставляем туда этот элемент.
4. Повторяем процесс до конца массива.
### __Код выводит:__  
Исходный массив: [64, 34, 25, 12, 22, 11, 90] 
Отсортированный массив:[ 11, 12, 22, 25, 34, 64, 90]
### __Оценка временной сложности:__
О(n²) в худшем и среднем случаях, однако для почти отсортированных массивов она приближается к O(n).

## 4. Анализ алгоритма сортировкаи слиянием 
### Определение:
Сортировка слиянием (Merge Sort) — алгоритм состоит в разделении массива пополам, сортировке половин и их слиянии.
### __Как работает:__
1. Использует принцип "разделяй и властвуй": массив делится на небольшие части, каждая из которых сортируется отдельно, потом объединяются.
2. Время работы одинаково для лучшего, среднего и худшего случаев.
### __Код выводит:__  
Исходный массив: [38, 27, 43, 3, 9, 82, 10]
Отсортированный массив: [3, 9, 10, 27, 38, 43, 82]
### __Оценка временной сложности:__
O(n log n).

## 5. Анализ алгоритма сортировки Шелла 
### Определение:
Сортировка Шелла (Shellsort) — является модификацией сортировки вставками, сортирует между собой элементы, стоящие на местах, кратных определённому шагу. 
### __Как работает:__
1. Улучшенная версия сортировки вставками, использующая интервалы для повышения производительности.
2. Расстояние уменьшается на каждом этапе.
### __Код выводит:__  
Отсортированный массив: [2, 3, 12, 34, 54]
### __Оценка временной сложности:__
Зависит от начальной величины шага, в среднем О(n^1.25) (усреднённая оценка).

## 6. Анализ алгоритма быстрой сортировки
### Определение:
Быстрая сортировка (Quick Sort) — один из самых известных и широко используемых алгоритмов сортировки. Алгоритм состоит в выборе опорного элемента, разделении массива на две части относительно опорного (одна — все элементы, меньшие опорного элемента, вторая — большие), и в сортировке полученных частей рекурсивным вызовом себя от них.
### __Как работает:__
1.	Опорный элемент ("pivot") выбран как последний элемент массива.
2.	Все элементы меньше опорного отправляются в левую часть, остальные — в правую.
3.	Затем каждая половина сортируется отдельно.
### __Код выводит:__  
Отсортированный массив: [1, 5, 7, 8, 9, 10] 
### __Оценка временной сложности:__
Средняя O(n log n), худшая О(n²) (при неудачном выборе опорного элемента).

## 7. Анализ алгоритма пирамидальной сортировки
### Определение:
Пирамидальная сортировка (Heap Sort) — алгоритм строит кучу из исходного списка, затем постепенно извлекает наибольший элемент из кучи и помещает его в конец списка.
### __Как работает:__
1.	Сначала строится двоичное дерево (heap), затем максимальные элементы вытаскиваются и складываются в конце массива.
2.	Используется структура типа дерева для поддержания порядка.
### __Код выводит:__  
Отсортированный массив: [5, 6, 7, 11, 12, 13]
### __Оценка временной сложности:__
O(n log n).

# *Алгоритмы поиска*
## 1. Анализ алгоритма линейного поиска
### Определение:
Последовательный (линейный) поиск (Linear Search) — простейший вид поиска заданного элемента на некотором множестве. Осуществляется путём последовательного сравнения очередного рассматриваемого значения с искомым до тех пор, пока эти значения не совпадут. Этот метод является наименее эффективным, так как его временная сложность составляет O(n), где n — количество элементов в списке. Однако он прост в реализации и может быть полезен для небольших списков или в тех случаях, когда данные не отсортированы.
### __Как работает:__
1.	Линейный поиск последовательно просматривает каждый элемент массива.
2.	Подходит для малых размеров или несортированных данных.
3.	Завершается сразу же, как только найден нужный элемент.
### __Код выводит:__  
Элемент найден на позиции: 3
### __Оценка временной сложности:__
O(n), где n — длина массива.

## 2. Анализ алгоритма бинарного поиска
### Определение:
Бинарный (двоичный, дихотомический) поиск (Binary Search) — это поиск заданного элемента на упорядоченном множестве, осуществляемый путём неоднократного деления этого множества на две части таким образом, что искомый элемент попадает в одну из этих частей. Поиск заканчивается при совпадении искомого элемента с элементом, который является границей между частями множества или при отсутствии искомого элемента. Преимуществом бинарного поиска является более низкая трудоёмкость по сравнению с последовательным поиском. Недостаток заключается в том, что он применим только на отсортированных множествах.
### __Как работает:__
1.	Подразумевает наличие отсортированного массива.
2.	Производится деление области поиска пополам, сокращая пространство поиска на каждом шаге.
### __Код выводит:__  
Элемент найден на позиции: 3
### __Оценка временной сложности:__
Бинарный поиск имеет логарифмическое поведение, так как на каждом шаге мы исключаем половину оставшихся элементов, поэтому сложность равна O(log n).

## 3. Анализ алгоритма интерполяционного поиска
### Определение:
Интерполирующий поиск (Interpolation Search) — это алгоритм поиска для отсортированных наборов данных, таких как массивы или списки. Он предсказывает позицию нужного элемента на основе разницы значений. Эффективен, если элементы распределены достаточно равномерно.
### __Как работает:__
1.	Рассчитывается приблизительная позиция искомого элемента, исходя из распределения значений.
2.	Лучше всего подходит для равномерных распределённых данных.
### __Код выводит:__  
Элемент найден на позиции: 4
### __Оценка временной сложности:__
Оптимизированная форма — O(loglogn) при равномерном распределении, иначе O(n).

## 4. Анализ алгоритма фибоначчиевого поиска
### Определение:
Поиск по Фибоначчи (Fibonacci Search) — это эффективный алгоритм поиска, используемый для нахождения целевого значения в отсортированной коллекции, такой как массив или список. По принципу он аналогичен бинарному поиску, но использует числа Фибоначчи для определения позиций для сравнения.
### __Как работает:__
1.	Использование числовой последовательности Фибоначчи для определения шагов.
2.	Это альтернативный подход к бинарному поиску, позволяющий эффективно искать элементы в отсортированных массивах.
### __Код выводит:__  
Элемент найден на позиции: 8
### __Оценка временной сложности:__
Подобно бинарному поиску, этот алгоритм обладает логарифмическим поведением благодаря своей стратегии быстрого уменьшения пространства поиска, поэтому временная сложность алгоритма тоже O(log n).


# Общий вывод
Рассмотрев различные алгоритмы сортировки и поиска, можно сделать следующие общие выводы:
1. Самые быстрые и эффективные алгоритмы сортировки — это алгоритмы "разделяй и властвуй": быстрая сортировка и сортировка слиянием, имеющие среднюю сложность 
O(N⋅logN). Эти алгоритмы подходят для обработки больших объемов данных.
2. Среди простых методов выделяются сортировка выбором, сортировка вставками и пузырьковая сортировка, но они менее эффективны (
O(N 2)) и пригодны лишь для маленьких массивов или учебных примеров.
3. Из алгоритмов поиска наиболее быстрым является бинарный поиск O(logN)), работающий только на предварительно отсортированных данных. Другие виды поиска, такие как линейный (O(N)), подходят для небольших массивов или когда предварительная сортировка невозможна.
4. Дополнительные варианты, такие как интерполяционный поиск и фибоначчиеский поиск, предлагают улучшенную скорость поиска на специфически распределённых данных, хотя и остаются ограниченными условиями сортировки.

### Подводя итог, выбор оптимального алгоритма зависит от характера задачи: для больших объемов данных приоритет отдают быстрому решению, а для маленьких или специальных ситуаций применяют упрощённые методы.
