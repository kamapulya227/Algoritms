# Контрольная работа по алгоритмическим структурам сортировки и поиска на языках: C++, Python, Java. (Хусяинова Камиля, УИБО-10-24)
# *Алгоритмы сортировки*
## 1. Сортировка выбором
### Сортировка выбором (Selection Sort) — на каждом шаге алгоритма находят минимальный элемент среди последних и меняют его местами с текущим элементом в массиве.
### **Реализация на C++:** 
```
include <iostream>
using namespace std;
// Функция сортировки выбором
void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; ++i) { // Внешний цикл перебирает первые n-1 элементов
        int minIndex = i;              // Индексация минимального элемента
        
        // Внутренний цикл ищет минимум в неотсортированной части
        for (int j = i + 1; j < n; ++j) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;          // Обновление индекса минимума
            }
        }
        
        // Обмен найденного минимального элемента с текущим
        swap(arr[i], arr[minIndex]);
    }
}

// Основная функция для демонстрации
int main() {
    int arr[] = {64, 25, 12, 22, 11};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    cout << "Исходный массив:\n";
    for (int i = 0; i < n; ++i) {
        cout << arr[i] << " ";
    }
    cout << "\n\n";
    
    selectionSort(arr, n);
    
    cout << "Отсортированный массив:\n";
    for (int i = 0; i < n; ++i) {
        cout << arr[i] << " ";
    }
    cout << "\n";
    
    return 0;
}
```
### __Как работает:__
1. Внешний цикл (for) последовательно перебирает элементы массива слева направо.
2. Для каждого шага внешнего цикла выполняется внутренняя проверка оставшихся элементов для поиска минимального.
3. Найденный минимальный элемент заменяется с текущим элементом внешней проверки.
### __Код выводит:__  
Отсортированный массив: [11, 12, 22, 25, 64]
### __Оценка временной сложности:__
О(n²), где n — длина массива.
## 2. Сортировка обменом (пузырьком)
### Сортировка обменом (пузырьком) (Bubble Sort) — алгоритм проходит по списку несколько раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Процесс повторяется до тех пор, пока список полностью не отсортируется.
### **Реализация на Python:**
```
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        swapped = False
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        if not swapped:
            break

test_array = [64, 34, 25, 12, 22, 11, 90]
print("Исходный массив:", test_array)
bubble_sort(test_array)
print("Отсортированный массив:", test_array)
```
### __Как работает:__
1. Во внешнем цикле пробегаемся по всему массиву столько раз, сколько элементов.
2. Во внутреннем цикле выполняем сравнительные операции и меняем элементы местами, если порядок неверный.
3. Операция останавливается досрочно, если ни одна пара не была поменяна местами.
### __Код выводит:__  
Исходный массив: [64, 34, 25, 12, 22, 11, 90]
Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]
### __Оценка временной сложности:__
О(n²), оптимизация даёт лучшую производительность в почти отсортированном массиве (O(n)).
## 3. Сортировка вставками
### Сортировка вставками (Insertion Sort) — алгоритм строит отсортированную часть списка, постепенно вставляя каждый элемент на своё место. Он начинает с первого элемента и перемещается вправо, сравнивая каждый элемент с предыдущими элементами и вставляя его на правильное место.
### **Реализация на C++:**
```
#include <iostream>
using namespace std;

// Основной метод сортировки вставками
void insertionSort(int arr[], int size) {
    int key, j;
    
    // Проходим по каждому элементу начиная со второго элемента
    for (int i = 1; i < size; ++i) {
        key = arr[i];   // Берём текущий элемент
        j = i - 1;      // Индекс предыдущего элемента
        
        /* Перемещаем все элементы слева от текущего,
           которые больше key, вправо */
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];     // Смещение большего элемента направо
            j--;
        }
        
        // Размещаем ключ на правильную позицию
        arr[j + 1] = key;
    }
}

// Тестовая программа
int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr)/sizeof(arr[0]);
    
    cout << "Исходный массив:\n";
    for (int i=0; i<n; i++)
        cout << arr[i] << " ";
    
    insertionSort(arr, n);
    
    cout << "\nОтсортированный массив:\n";
    for (int i=0; i<n; i++)
        cout << arr[i] << " ";
    
    return 0;
}
```
### __Как работает:__
1. Сначала мы проходим по массиву, начиная со второго элемента (arr[1]), считая первые два элемента частью уже отсортированного участка.
2. Для каждого нового элемента (key) ищем подходящую позицию в левой части массива путём сдвига больших элементов вправо.
3. Когда подходящее место найдено, вставляем туда этот элемент.
4. Повторяем процесс до конца массива.
### __Код выводит:__  
Исходный массив: [64, 34, 25, 12, 22, 11, 90] 
Отсортированный массив:[ 11, 12, 22, 25, 34, 64, 90]
### __Оценка временной сложности:__
О(n²) в худшем и среднем случаях, однако для почти отсортированных массивов она приближается к O(n).
## 4. Сортировка слиянием 
### Сортировка слиянием (Merge Sort) — алгоритм состоит в разделении массива пополам, сортировке половин и их слиянии.
### **Реализация на Java:**
```
import java.util.Arrays;

public class MergeSortExample {
    public static void mergeSort(int[] arr) {
        if (arr.length > 1) {
            int mid = arr.length / 2;
            
            // Разделяем массив на две части
            int[] left = Arrays.copyOfRange(arr, 0, mid);
            int[] right = Arrays.copyOfRange(arr, mid, arr.length);
            
            // Рекурсивно сортируем обе части
            mergeSort(left);
            mergeSort(right);
            
            // Объединяем отсортированные части
            merge(arr, left, right);
        }
    }
    
    private static void merge(int[] arr, int[] left, int[] right) {
        int l = 0, r = 0, k = 0;
        while (l < left.length && r < right.length) {
            if (left[l] <= right[r])
                arr[k++] = left[l++];
            else
                arr[k++] = right[r++];
        }
        while (l < left.length)
            arr[k++] = left[l++];
        while (r < right.length)
            arr[k++] = right[r++];
    }
    
    public static void main(String[] args) {
        int[] array = {38, 27, 43, 3, 9, 82, 10};
        System.out.println("Исходный массив:");
        System.out.println(Arrays.toString(array));
        
        mergeSort(array);
        
        System.out.println("\nОтсортированный массив:");
        System.out.println(Arrays.toString(array));
    }
}
```
### __Как работает:__
1. Использует принцип "разделяй и властвуй": массив делится на небольшие части, каждая из которых сортируется отдельно, потом объединяются.
2. Время работы одинаково для лучшего, среднего и худшего случаев.
### __Код выводит:__  
Исходный массив: [38, 27, 43, 3, 9, 82, 10]
Отсортированный массив: [3, 9, 10, 27, 38, 43, 82]
### __Оценка временной сложности:__
O(n log n).
## 5. Сортировка Шелла 
### Сортировка Шелла (Shellsort) — является модификацией сортировки вставками, сортирует между собой элементы, стоящие на местах, кратных определённому шагу. 
### **Реализация на Python:**
```
def shell_sort(arr):
    n = len(arr)
    gap = n // 2  # Начальное расстояние
    
    while gap > 0:
        for i in range(gap, n):
            temp = arr[i]
            j = i
            while j >= gap and arr[j-gap] > temp:
                arr[j] = arr[j-gap]
                j -= gap
            arr[j] = temp
        gap //= 2  # Уменьшение расстояния

test_array = [12, 34, 54, 2, 3]
shell_sort(test_array)
print("Отсортированный массив:", test_array)
```
### __Как работает:__
1. Улучшенная версия сортировки вставками, использующая интервалы для повышения производительности.
2. Расстояние уменьшается на каждом этапе.
### __Код выводит:__  
Отсортированный массив: [2, 3, 12, 34, 54]
### __Оценка временной сложности:__
Зависит от начальной величины шага, в среднем О(n^1.25) (усреднённая оценка).
## 6. Быстрая сортировка 
### Быстрая сортировка (Quick Sort) — один из самых известных и широко используемых алгоритмов сортировки. Алгоритм состоит в выборе опорного элемента, разделении массива на две части относительно опорного (одна — все элементы, меньшие опорного элемента, вторая — большие), и в сортировке полученных частей рекурсивным вызовом себя от них.
### **Реализация на C++:**
```
#include <iostream>
using namespace std;

// Процедура разделения массива вокруг опорного элемента
int partition(int arr[], int low, int high) {
    int pivot = arr[high];                    // Опорный элемент
    int i = low - 1;                         // Начальное положение маленького элемента
    
    // Цикл перемещения элементов относительно опорного
    for (int j = low; j <= high - 1; ++j) {
        if (arr[j] < pivot) {                 // Если элемент меньше опорного
            i++;
            swap(arr[i], arr[j]);             // Обмен текущего и следующего
        }
    }
    
    // Поместить опорный элемент на свою финальную позицию
    swap(arr[i + 1], arr[high]);
    return i + 1;
}

// Основная процедура быстрой сортировки
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        // Разделение массива и получение позиции опоры
        int pi = partition(arr, low, high);
        
        // Рекурсивно сортируем левую и правую части
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

// Основная функция для демонстрации
int main() {
    int arr[] = {10, 7, 8, 9, 1, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    cout << "Исходный массив:\n";
    for (int i = 0; i < n; ++i) {
        cout << arr[i] << " ";
    }
    cout << "\n\n";
    
    quickSort(arr, 0, n - 1);
    
    cout << "Отсортированный массив:\n";
    for (int i = 0; i < n; ++i) {
        cout << arr[i] << " ";
    }
    cout << "\n";
    
    return 0;
}
```
### __Как работает:__
1.	Опорный элемент ("pivot") выбран как последний элемент массива.
2.	Все элементы меньше опорного отправляются в левую часть, остальные — в правую.
3.	Затем каждая половина сортируется отдельно.
### __Код выводит:__  
Отсортированный массив: [1, 5, 7, 8, 9, 10] 
### __Оценка временной сложности:__
Средняя O(n log n), худшая О(n²) (при неудачном выборе опорного элемента).
## 7. Пирамидальная сортировка
### Пирамидальная сортировка (Heap Sort) — алгоритм строит кучу из исходного списка, затем постепенно извлекает наибольший элемент из кучи и помещает его в конец списка.
### **Реализация на Python:**
```
def heapify(arr, n, i):
    largest = i   # root is the largest initially
    left = 2 * i + 1
    right = 2 * i + 2
    
    # Check if left child exists and is greater than root
    if left < n and arr[i] < arr[left]:
        largest = left
    
    # Check if right child exists and is greater than root
    if right < n and arr[largest] < arr[right]:
        largest = right
    
    # If root isn't the largest, swap it with the larger one
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)
    
    # Build max-heap
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    
    # Extract elements from heap
    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # Swap root (max) to end of array
        heapify(arr, i, 0)              # Heapify reduced heap

test_array = [12, 11, 13, 5, 6, 7]
heap_sort(test_array)
print("Отсортированный массив:", test_array)
```
### __Как работает:__
1.	Сначала строится двоичное дерево (heap), затем максимальные элементы вытаскиваются и складываются в конце массива.
2.	Используется структура типа дерева для поддержания порядка.
### __Код выводит:__  
Отсортированный массив: [5, 6, 7, 11, 12, 13]
### __Оценка временной сложности:__
O(n log n).
# *Алгоритмы поиска*
## 1. Линейный поиск 
### Последовательный (линейный) поиск (Linear Search) — простейший вид поиска заданного элемента на некотором множестве. Осуществляется путём последовательного сравнения очередного рассматриваемого значения с искомым до тех пор, пока эти значения не совпадут. Этот метод является наименее эффективным, так как его временная сложность составляет O(n), где n — количество элементов в списке. Однако он прост в реализации и может быть полезен для небольших списков или в тех случаях, когда данные не отсортированы.
### **Реализация на C++:**
```
#include <iostream>
using namespace std;

// Функция линейного поиска
int linearSearch(int arr[], int size, int target) {
    for (int i = 0; i < size; ++i) {
        if (arr[i] == target) {
            return i;                       // Вернуть индекс найденного элемента
        }
    }
    return -1;                             // Элемента нет в массиве
}

// Основная функция для демонстрации
int main() {
    int arr[] = {3, 5, 2, 7, 9, 1, 4};
    int size = sizeof(arr) / sizeof(arr[0]);
    int target = 7;
    
    int index = linearSearch(arr, size, target);
    
    if (index != -1) {
        cout << "Элемент найден на позиции: " << index << endl;
    } else {
        cout << "Элемент не найден." << endl;
    }
    
    return 0;
}
```
### __Как работает:__
1.	Линейный поиск последовательно просматривает каждый элемент массива.
2.	Подходит для малых размеров или несортированных данных.
3.	Завершается сразу же, как только найден нужный элемент.
### __Код выводит:__  
Элемент найден на позиции: 3
### __Оценка временной сложности:__
O(n), где n — длина массива.
## 2. Бинарный поиск 
### Бинарный (двоичный, дихотомический) поиск (Binary Search) — это поиск заданного элемента на упорядоченном множестве, осуществляемый путём неоднократного деления этого множества на две части таким образом, что искомый элемент попадает в одну из этих частей. Поиск заканчивается при совпадении искомого элемента с элементом, который является границей между частями множества или при отсутствии искомого элемента. Преимуществом бинарного поиска является более низкая трудоёмкость по сравнению с последовательным поиском. Недостаток заключается в том, что он применим только на отсортированных множествах.
### **Реализация на Java:**
```
public class BinarySearch {
    public static int binarySearch(int[] array, int target) {
        int left = 0;
        int right = array.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (array[mid] == target) {
                return mid;  // Найден элемент
            }
            
            if (target < array[mid]) {
                right = mid - 1;  // Поиск в левой половине
            } else {
                left = mid + 1;   // Поиск в правой половине
            }
        }
        return -1;  // Элемент не найден
    }
    
    public static void main(String[] args) {
        int[] sortedArray = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19};
        int target = 7;
        
        int result = binarySearch(sortedArray, target);
        if (result != -1) {
            System.out.println("Элемент найден на позиции: " + result);
        } else {
            System.out.println("Элемент не найден");
        }
    }
}
```
### __Как работает:__
1.	Подразумевает наличие отсортированного массива.
2.	Производится деление области поиска пополам, сокращая пространство поиска на каждом шаге.
### __Код выводит:__  
Элемент найден на позиции: 3
### __Оценка временной сложности:__
Бинарный поиск имеет логарифмическое поведение, так как на каждом шаге мы исключаем половину оставшихся элементов, поэтому сложность равна O(log n).
## 3. Интерполяционный поиск 
### Интерполирующий поиск (Interpolation Search) — это алгоритм поиска для отсортированных наборов данных, таких как массивы или списки. Он предсказывает позицию нужного элемента на основе разницы значений. Эффективен, если элементы распределены достаточно равномерно.
### **Реализация на Python:**
```
def interpolation_search(arr, lo, hi, x):
    if (lo <= hi and x >= arr[lo] and x <= arr[hi]):
        pos = lo + ((hi - lo) * (x - arr[lo]) // (arr[hi] - arr[lo]))
        
        if arr[pos] == x:
            return pos
        
        elif arr[pos] < x:
            return interpolation_search(arr, pos + 1, hi, x)
        
        else:
            return interpolation_search(arr, lo, pos - 1, x)
    return -1

sorted_arr = [10, 12, 13, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47]
x = 18
index = interpolation_search(sorted_arr, 0, len(sorted_arr)-1, x)
if index != -1:
    print(f"Элемент найден на позиции: {index}")
else:
    print("Элемент не найден")
```
### __Как работает:__
1.	Рассчитывается приблизительная позиция искомого элемента, исходя из распределения значений.
2.	Лучше всего подходит для равномерных распределённых данных.
### __Код выводит:__  
Элемент найден на позиции: 4
### __Оценка временной сложности:__
Оптимизированная форма — O(loglogn) при равномерном распределении, иначе O(n).
## 4. Фибоначчиевый поиск
### Поиск по Фибоначчи (Fibonacci Search) — это эффективный алгоритм поиска, используемый для нахождения целевого значения в отсортированной коллекции, такой как массив или список. По принципу он аналогичен бинарному поиску, но использует числа Фибоначчи для определения позиций для сравнения.
### **Реализация на Java:**
```
public class FibonacciSearch {
    public static int fibonacciSearch(int[] arr, int x) {
        int fibMm2 = 0; // (m-2)'е число Фибоначчи
        int fibMm1 = 1; // (m-1)'е число Фибоначчи
        int fibM = fibMm2 + fibMm1; // Число Фибоначчи >= длина массива
        
        while (fibM < arr.length) {
            fibMm2 = fibMm1;
            fibMm1 = fibM;
            fibM = fibMm2 + fibMm1;
        }
        
        int offset = -1;
        
        while (fibM > 1) {
            int i = Math.min(offset + fibMm2, arr.length - 1);
            
            if (arr[i] < x) {
                fibM = fibMm1;
                fibMm1 = fibMm2;
                fibMm2 = fibM - fibMm1;
                offset = i;
            } else if (arr[i] > x) {
                fibM = fibMm2;
                fibMm1 = fibMm1 - fibMm2;
                fibMm2 = fibM - fibMm1;
            } else {
                return i;
            }
        }
        
        if (fibMm1 != 0 && offset + 1 < arr.length && arr[offset + 1] == x) {
            return offset + 1;
        }
        return -1;
    }
    
    public static void main(String[] args) {
        int[] sortedArr = {10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100};
        int searchElement = 85;
        int foundIndex = fibonacciSearch(sortedArr, searchElement);
        if (foundIndex != -1) {
            System.out.println("Элемент найден на позиции: " + foundIndex);
        } else {
            System.out.println("Элемент не найден");
        }
    }
}
```
### __Как работает:__
1.	Использование числовой последовательности Фибоначчи для определения шагов.
2.	Это альтернативный подход к бинарному поиску, позволяющий эффективно искать элементы в отсортированных массивах.
### __Код выводит:__  
Элемент найден на позиции: 8
### __Оценка временной сложности:__
Подобно бинарному поиску, этот алгоритм обладает логарифмическим поведением благодаря своей стратегии быстрого уменьшения пространства поиска, поэтому временная сложность алгоритма тоже O(log n).
# Общий вывод
Рассмотрев различные алгоритмы сортировки и поиска, можно сделать следующие общие выводы:
1. Самые быстрые и эффективные алгоритмы сортировки — это алгоритмы "разделяй и властвуй": быстрая сортировка и сортировка слиянием, имеющие среднюю сложность 
O(N⋅logN). Эти алгоритмы подходят для обработки больших объемов данных.
2. Среди простых методов выделяются сортировка выбором, сортировка вставками и пузырьковая сортировка, но они менее эффективны (
O(N 2)) и пригодны лишь для маленьких массивов или учебных примеров.
3. Из алгоритмов поиска наиболее быстрым является бинарный поиск O(logN)), работающий только на предварительно отсортированных данных. Другие виды поиска, такие как линейный (O(N)), подходят для небольших массивов или когда предварительная сортировка невозможна.
4. Дополнительные варианты, такие как интерполяционный поиск и фибоначчиеский поиск, предлагают улучшенную скорость поиска на специфически распределённых данных, хотя и остаются ограниченными условиями сортировки.
### Подводя итог, выбор оптимального алгоритма зависит от характера задачи: для больших объемов данных приоритет отдают быстрому решению, а для маленьких или специальных ситуаций применяют упрощённые методы.
