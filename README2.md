# __Задание 3: Работа с массивами__
# Вариант 7
## Задача:
__Напишите рекурсивную функцию для нахождения максимального элемента в массиве.__
## Как работает алгоритм для Python:
  Функция принимает массив ```arr``` и его длину ```n```. Базис рекурсии: если ```n == 1```, возвращаем единственный элемент ```arr[0]```. Рекурсивный вызов: ищем максимум в подмассиве длины ```n‑1``` (без последнего элемента). Сравнение: сравниваем последний элемент ```arr[n‑1]``` с найденным максимумом остатка. Возврат: возвращаем больший из двух.
## Как работает алгоритм для C++:
  Функция принимает константную ссылку на вектор ```arr``` и длину ```n```. Базис: при ```n == 1``` возвращаем ```arr[0]```. Рекурсия: вызываем ```find_max``` для ```n‑1```, сохраняем результат в ```max_of_rest```. Сравнение: используем тернарный оператор для выбора максимума между ```arr[n‑1]``` и ```max_of_rest```. Возврат выбранного значения.
## Как работает алгоритм для Java:
   Функция принимает массив ```arr``` и длину ```n```. Базис: если ```n == 1```, возвращаем ```arr[0]```. Рекурсия: вызываем ```findMax для n‑1```, сохраняем результат в ```maxOfRest```. Сравнение: через тернарный оператор выбираем максимум между ```arr[n‑1]``` и ```maxOfRest```. Возврат результата.
## На выходе в каждом коде получается: 
Максимальный элемент: 9
## Временная сложность:
_O(n)_
## Почему эта временная сложность?
Сложность _O(n)_ обусловлена тем, что:

    1. алгоритм делает n рекурсивных шагов,

    2. на каждом шаге выполняется константное количество операций,

    3. все n элементов обрабатываются ровно по одному разу.

Это оптимальная сложность для задачи поиска максимума, так как любой алгоритм обязан хотя бы один раз «посмотреть» на каждый элемент массива.
## Контрольный вопрос №5 :
### Стратегия «разделяй и властвуй»
Это схема проектирования алгоритмов, основанная на рекурсивном разбиении исходной задачи на более простые подзадачи того же типа, но меньшего размера. После решения подзадач их результаты комбинируются для получения итогового ответа.

### Три ключевых этапа:

    1. Разделение — разбиение задачи на подзадачи.

    2. Решениеение — рекурсивное решение подзадач (или прямое решение, если подзадача элементарна).

    3. Объединение — слияние решений подзадач в решение исходной задачи.

### Сортировка слиянием (Merge Sort) — классический пример применения подхода «разделяй и властвуй». Алгоритм был разработан Джоном фон Нейманом в 1945 году.
Пошаговое описание

  Разделение
  
    Массив рекурсивно делится на две примерно равные части до тех пор, пока каждый подмассив не будет содержать один элемент (тривиально отсортирован).
    Пример для массива [38, 27, 43, 3, 9, 82, 10]:

        Первый уровень: [38, 27, 43, 3] и [9, 82, 10]

        Второй уровень: [38, 27], [43, 3], [9, 82], [10]

        Третий уровень: [38], [27], [43], [3], [9], [82], [10]

   Решение подзадач
   
    Каждый одиночный элемент считается отсортированным. Рекурсия останавливается на этом уровне.

  Слияние
  
    Отсортированные подмассивы попарно объединяются в упорядоченные массивы большего размера:

        Слияние [38] и [27] → [27, 38]

        Слияние [43] и [3] → [3, 43]

        Слияние [9] и [82] → [9, 82]

        Далее: [27, 38] и [3, 43] → [3, 27, 38, 43]

        Наконец: [3, 27, 38, 43] и [9, 82, 10] → полный отсортированный массив

Алгоритм слияния двух отсортированных массивов

Для объединения двух подмассивов:

    Сравниваются первые элементы каждого подмассива.

    Меньший элемент перемещается в результирующий массив.

    Процесс повторяется, пока один из подмассивов не опустеет.

    Оставшиеся элементы второго подмассива дописываются в конец результата.
Псевдокод:
```
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)


def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result
```

Характеристики алгоритма

    Временная сложность: O(nlogn)

        Разделение выполняется log2​n раз.

        Каждое слияние требует O(n) операций.

    Пространственная сложность: O(n)

        Требуется дополнительная память для временных массивов при слиянии.

    Стабильность: Да

        Сохраняет порядок равных элементов.

    Гарантированная производительность: Всегда O(nlogn), в отличие от быстрой сортировки.

Преимущества и недостатки

Плюсы:

    Предсказуемая производительность.

    Подходит для больших данных и внешних сортировок (когда данные не помещаются в оперативную память).

    Хорошо параллелизуется.

Минусы:

    Требует дополнительной памяти O(n).

    Менее эффективен на малых массивах из‑за рекурсивных вызовов.

Итог

Сортировка слиянием демонстрирует мощь стратегии «разделяй и властвуй»:

    Сложная задача (сортировка большого массива) разбивается на простые подзадачи (сортировка одиночных элементов).

    Решения подзадач комбинируются через слияние.

    Результат — эффективный алгоритм с гарантированной сложностью O(nlogn).
