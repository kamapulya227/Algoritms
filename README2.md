# __Задание 3: Работа с массивами__
# Вариант 7
## Задача:
__Напишите рекурсивную функцию для нахождения максимального элемента в массиве.__
## Как работает алгоритм для Python:
  Функция принимает массив ```arr``` и его длину ```n```. Базис рекурсии: если ```n == 1```, возвращаем единственный элемент ```arr[0]```. Рекурсивный вызов: ищем максимум в подмассиве длины ```n‑1``` (без последнего элемента). Сравнение: сравниваем последний элемент ```arr[n‑1]``` с найденным максимумом остатка. Возврат: возвращаем больший из двух.
## Как работает алгоритм для C++:
  Функция принимает константную ссылку на вектор ```arr``` и длину ```n```. Базис: при ```n == 1``` возвращаем ```arr[0]```. Рекурсия: вызываем ```find_max``` для ```n‑1```, сохраняем результат в ```max_of_rest```. Сравнение: используем тернарный оператор для выбора максимума между ```arr[n‑1]``` и ```max_of_rest```. Возврат выбранного значения.
## Как работает алгоритм для Java:
   Функция принимает массив ```arr``` и длину ```n```. Базис: если ```n == 1```, возвращаем ```arr[0]```. Рекурсия: вызываем ```findMax для n‑1```, сохраняем результат в ```maxOfRest```. Сравнение: через тернарный оператор выбираем максимум между ```arr[n‑1]``` и ```maxOfRest```. Возврат результата.
## На выходе в каждом коде получается: 
Максимальный элемент: 9
## Временная сложность:
_O(n)_
## Почему эта временная сложность?
Сложность _O(n)_ обусловлена тем, что:

    1. алгоритм делает n рекурсивных шагов,

    2. на каждом шаге выполняется константное количество операций,

    3. все n элементов обрабатываются ровно по одному разу.

Это оптимальная сложность для задачи поиска максимума, так как любой алгоритм обязан хотя бы один раз «посмотреть» на каждый элемент массива.

