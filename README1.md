# Практическая работа. Хусяинова Камиля. УИБО-10-24
# Вариант 5. Покрытие множеств с жадным алгоритмом
# Задача: реализовать жадный ln(n)-аппроксимационный алгоритм для задачи о покрытии множеств.
## 1. Код на языке Python (в файле)

## 2. Анализ алгоритма
### Как работает алгоритм:
Программа начинается с ввода данных пользователем через ```input()```, преобразуя их в множества с помощью ```set(map(int, universe_input))```. Основная функция ```set_cover()``` использует жадную стратегию: инициализирует множество uncovered для отслеживания непокрытых элементов и списки ```selected_subsets```, ```subset_names``` для результатов.

В основном цикле ```while uncovered``` and ```subsets```: алгоритм перебирает все подмножества, используя ```enumerate(subsets)```, и для каждого вычисляет пересечение с непокрытыми элементами через ```uncovered.intersection(subset)```. Выбирается подмножество с максимальным размером пересечения ```(len(current_cover) > len(best_cover))```.

После выбора подмножество добавляется в результаты через ```append()```, покрытые элементы удаляются оператором ```uncovered -= best_cover```, а использованное подмножество исключается из дальнейшего рассмотрения с помощью ```pop(best_index)```.

В завершение создается множество ```covered_elements```, куда через ```update()``` собираются все элементы из выбранных подмножеств, и возвращается кортеж с результатами, включая количество покрытых элементов через ```len(covered_elements)```.

## 3. Временная сложность
O(m² × n)
## 4. Почему возникает эта временная сложность?
Временная сложность O(m² × n) возникает из-за вложенных циклов и операции пересечения множеств на каждом шаге алгоритма: внешний цикл выполняется m раз, внутренний проходит в среднем m/2 подмножеств, и для каждого выполняется операция ```intersection()``` за O(n), где n - размер универсума.

## 5. Контрольный вопрос №5
### Вопрос: Почему жадный алгоритм для 0-1 рюкзака не гарантирует оптимальное решение? Приведите контрпример.
#### Ответ: Жадный алгоритм для 0-1 рюкзака не гарантирует оптимальное решение, потому что он делает локально оптимальный выбор на каждом шаге (выбирает предметы с наибольшим отношением стоимости к весу), но не учитывает глобальную оптимальность.

#### Контрпример:

Пусть вместимость рюкзака W = 10, и есть предметы:
- Предмет 1: вес = 6, стоимость = 12 (отношение = 2.0)
- Предмет 2: вес = 5, стоимость = 9 (отношение = 1.8)
- Предмет 3: вес = 5, стоимость = 9 (отношение = 1.8)

Жадный алгоритм:
1. Выберет предмет 1 (отношение 2.0)
2. Оставшаяся вместимость: 4
3. Не может добавить предметы 2 и 3 (вес 5 > 4)
4. Итог: стоимость = 12


Оптимальное решение:
- Предметы 2 и 3: вес = 5 + 5 = 10, стоимость = 9 + 9 = 18

#### Таким образом, жадный алгоритм дает стоимость 12, в то время как оптимальное решение имеет стоимость 18. Это происходит потому, что жадный выбор первого предмета не позволяет взять комбинацию из двух других предметов, которая в целом дает большую стоимость.

